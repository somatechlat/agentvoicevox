"""
Billing and Usage Tracking Models
===================================

This module defines the core data models for the application's billing system.
It tracks `UsageEvent`s (billable actions and resource consumption), `BillingAlert`s
(notifications for usage thresholds or payment issues), and `Invoice` records
(synchronized from an external billing provider like Lago).
"""

import uuid

from django.db import models
from django.utils import timezone

from apps.api_keys.models import APIKey
from apps.projects.models import Project
from apps.tenants.models import TenantScopedManager, TenantScopedModel
from apps.users.models import User


class UsageEventManager(TenantScopedManager):
    """
    Custom manager for the `UsageEvent` model.

    Inherits from `TenantScopedManager` to ensure all queries are filtered
    by the current tenant. Provides helper methods for common usage event queries.
    """

    def for_period(
        self, start_date: timezone.datetime, end_date: timezone.datetime
    ) -> models.QuerySet:
        """
        Retrieves usage events within a specified date range.

        Args:
            start_date: The beginning of the date range (inclusive).
            end_date: The end of the date range (exclusive).

        Returns:
            A QuerySet of `UsageEvent` instances within the specified period.
        """
        return self.filter(
            created_at__gte=start_date,
            created_at__lt=end_date,
        )

    def unsynced(self) -> models.QuerySet:
        """
        Retrieves usage events that have not yet been successfully synced to Lago.
        """
        return self.filter(synced_at__isnull=True)


class UsageEvent(TenantScopedModel):
    """
    Represents a single billable event or unit of resource consumption.

    These events are typically generated by various parts of the application
    (e.g., session creation, API calls, LLM token usage) and are intended to
    be periodically synced to an external billing provider like Lago.
    """

    class EventType(models.TextChoices):
        """Defines the types of billable usage events."""

        SESSION = "session", "Voice Session"
        API_CALL = "api_call", "API Call"
        AUDIO_MINUTES = "audio_minutes", "Audio Minutes"
        INPUT_TOKENS = "input_tokens", "Input Tokens"
        OUTPUT_TOKENS = "output_tokens", "Output Tokens"
        STT_MINUTES = "stt_minutes", "STT Minutes"
        TTS_MINUTES = "tts_minutes", "TTS Minutes"

    # --- Core Identification ---
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)

    # --- Event Data ---
    event_type = models.CharField(
        max_length=50,
        choices=EventType.choices,
        db_index=True,
        help_text="The category of usage being tracked (e.g., 'api_call', 'audio_minutes').",
    )
    quantity = models.DecimalField(
        max_digits=20,
        decimal_places=6,
        help_text="The amount of usage for this event (e.g., 1 for an API call, 0.5 for half an audio minute).",
    )
    unit = models.CharField(
        max_length=50,
        default="count",
        help_text="The unit of measurement for the quantity (e.g., 'count', 'minutes', 'tokens').",
    )

    # --- Associations ---
    session = models.ForeignKey(
        "sessions.Session",
        on_delete=models.SET_NULL,  # If session is deleted, keep event but nullify association.
        null=True,
        blank=True,
        related_name="usage_events",
        help_text="The session associated with this usage event, if applicable.",
    )
    project = models.ForeignKey(
        Project,
        on_delete=models.SET_NULL,  # If project is deleted, keep event but nullify association.
        null=True,
        blank=True,
        related_name="usage_events",
        help_text="The project associated with this usage event, if applicable.",
    )
    api_key = models.ForeignKey(
        APIKey,
        on_delete=models.SET_NULL,  # If API key is deleted, keep event but nullify association.
        null=True,
        blank=True,
        related_name="usage_events",
        help_text="The API key used for this usage event, if applicable.",
    )

    # --- Lago Sync Status ---
    lago_event_id = models.CharField(
        max_length=255,
        blank=True,
        help_text="The unique ID assigned by Lago after successful synchronization of this event.",
    )
    synced_at = models.DateTimeField(
        null=True,
        blank=True,
        db_index=True,
        help_text="Timestamp when this event was successfully synced to Lago.",
    )
    sync_error = models.TextField(
        blank=True, help_text="Stores any error message if synchronization to Lago failed."
    )

    # --- Metadata and Timestamps ---
    metadata = models.JSONField(
        default=dict,
        blank=True,
        help_text="A flexible JSON field for storing additional, unstructured event metadata.",
    )
    created_at = models.DateTimeField(auto_now_add=True, db_index=True)
    event_timestamp = models.DateTimeField(
        default=timezone.now,
        help_text="The precise timestamp when the usage event actually occurred (can differ from `created_at`).",
    )

    # --- Django Manager ---
    objects = UsageEventManager()

    class Meta:
        """Model metadata options."""

        db_table = "usage_events"
        ordering = ["-event_timestamp"]  # Order by when the event actually happened.
        indexes = [
            models.Index(fields=["event_type"]),
            models.Index(fields=["synced_at"]),
            models.Index(fields=["tenant", "event_type"]),
            models.Index(fields=["tenant", "event_timestamp"]),
        ]

    def __str__(self) -> str:
        """Returns a string representation of the usage event."""
        return f"{self.event_type}: {self.quantity} {self.unit} for Tenant {self.tenant_id}"

    def mark_synced(self, lago_event_id: str) -> None:
        """
        Marks this usage event as successfully synchronized with Lago.

        Args:
            lago_event_id: The ID assigned to this event by Lago.
        """
        self.lago_event_id = lago_event_id
        self.synced_at = timezone.now()
        self.sync_error = ""  # Clear any previous errors.
        self.save(update_fields=["lago_event_id", "synced_at", "sync_error", "updated_at"])

    def mark_sync_error(self, error: str) -> None:
        """
        Records an error message if synchronization to Lago fails.

        Args:
            error: The error message from the Lago sync attempt.
        """
        self.sync_error = error
        self.synced_at = None  # Reset synced_at to indicate it needs another sync attempt.
        self.save(update_fields=["sync_error", "synced_at", "updated_at"])


class BillingAlert(TenantScopedModel):
    """
    Represents an alert triggered by billing-related events, such as exceeding
    usage thresholds or payment failures.

    Each alert is tenant-scoped and can be acknowledged by a user.
    """

    class AlertType(models.TextChoices):
        """Defines the categories of billing alerts."""

        USAGE_WARNING = (
            "usage_warning",
            "Usage Warning (80%)",
        )  # Tenant has used 80% of their limit.
        USAGE_CRITICAL = (
            "usage_critical",
            "Usage Critical (90%)",
        )  # Tenant has used 90% of their limit.
        LIMIT_EXCEEDED = "limit_exceeded", "Limit Exceeded"  # Tenant has exceeded their hard limit.
        PAYMENT_FAILED = "payment_failed", "Payment Failed"  # A payment attempt failed.
        SUBSCRIPTION_EXPIRING = (
            "subscription_expiring",
            "Subscription Expiring",
        )  # Subscription is nearing its end.

    # --- Core Identification ---
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)

    # --- Alert Details ---
    alert_type = models.CharField(
        max_length=50,
        choices=AlertType.choices,
        db_index=True,
        help_text="The type of billing alert.",
    )
    message = models.TextField(help_text="A human-readable message describing the alert.")
    resource_type = models.CharField(
        max_length=50,
        blank=True,
        help_text="The type of resource related to the alert (e.g., 'sessions', 'tokens', 'api_keys').",
    )
    current_value = models.DecimalField(
        max_digits=20,
        decimal_places=6,
        null=True,
        blank=True,
        help_text="The current usage or value that triggered the alert.",
    )
    threshold_value = models.DecimalField(
        max_digits=20,
        decimal_places=6,
        null=True,
        blank=True,
        help_text="The threshold value that was met or exceeded.",
    )

    # --- Acknowledgment Status ---
    acknowledged = models.BooleanField(
        default=False,
        db_index=True,
        help_text="True if the alert has been reviewed and acknowledged.",
    )
    acknowledged_at = models.DateTimeField(
        null=True, blank=True, help_text="Timestamp when the alert was acknowledged."
    )
    acknowledged_by = models.ForeignKey(
        User,
        on_delete=models.SET_NULL,  # Keep alert if the acknowledger user is deleted.
        null=True,
        blank=True,
        related_name="acknowledged_alerts",
        help_text="The user who acknowledged this alert.",
    )

    # --- Metadata and Timestamps ---
    metadata = models.JSONField(
        default=dict,
        blank=True,
        help_text="A flexible JSON field for additional, unstructured alert metadata.",
    )
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        """Model metadata options."""

        db_table = "billing_alerts"
        ordering = ["-created_at"]
        indexes = [
            models.Index(fields=["alert_type"]),
            models.Index(fields=["acknowledged"]),
            models.Index(fields=["tenant", "acknowledged"]),
        ]

    def __str__(self) -> str:
        """Returns a string representation of the billing alert."""
        return f"Billing Alert ({self.alert_type}): {self.message[:50]}"

    def acknowledge(self, user: User) -> None:
        """
        Marks the billing alert as acknowledged by a specific user.

        Args:
            user: The User instance who acknowledged the alert.
        """
        self.acknowledged = True
        self.acknowledged_at = timezone.now()
        self.acknowledged_by = user
        self.save(
            update_fields=["acknowledged", "acknowledged_at", "acknowledged_by", "updated_at"]
        )


class Invoice(TenantScopedModel):
    """
    Represents a billing invoice, typically synchronized from an external
    billing provider (like Lago).

    This model stores key invoice details for display within the portal,
    allowing tenants to view their past and upcoming charges.
    """

    class Status(models.TextChoices):
        """Defines the various statuses an invoice can have."""

        DRAFT = "draft", "Draft"
        FINALIZED = "finalized", "Finalized"
        PAID = "paid", "Paid"
        VOIDED = "voided", "Voided"
        FAILED = "failed", "Payment Failed"

    # --- Core Identification & Lago Integration ---
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    lago_invoice_id = models.CharField(
        max_length=255,
        unique=True,
        help_text="The unique identifier for this invoice in the Lago billing system.",
    )
    invoice_number = models.CharField(
        max_length=100, help_text="The human-readable invoice number."
    )

    # --- Amounts and Currency ---
    amount_cents = models.BigIntegerField(
        help_text="The subtotal amount of the invoice in cents (e.g., 10000 for $100.00)."
    )
    taxes_amount_cents = models.BigIntegerField(
        default=0, help_text="The total tax amount of the invoice in cents."
    )
    total_amount_cents = models.BigIntegerField(
        help_text="The total amount of the invoice including taxes, in cents."
    )
    currency = models.CharField(
        max_length=3,
        default="USD",
        help_text="The currency code for the invoice (e.g., 'USD', 'EUR').",
    )

    # --- Status and Dates ---
    status = models.CharField(
        max_length=20,
        choices=Status.choices,
        default=Status.DRAFT,
        db_index=True,
        help_text="The current status of the invoice.",
    )
    issuing_date = models.DateField(help_text="The date when the invoice was issued.")
    payment_due_date = models.DateField(
        null=True, blank=True, help_text="The date by which payment is due."
    )

    # --- Document Links and Metadata ---
    pdf_url = models.URLField(
        blank=True, help_text="A URL to the downloadable PDF version of the invoice."
    )
    metadata = models.JSONField(
        default=dict,
        blank=True,
        help_text="A flexible JSON field for additional, unstructured invoice metadata.",
    )

    # --- Timestamps ---
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        """Model metadata options."""

        db_table = "invoices"
        ordering = ["-issuing_date"]
        indexes = [
            models.Index(fields=["lago_invoice_id"]),
            models.Index(fields=["status"]),
            models.Index(fields=["tenant", "status"]),
            models.Index(fields=["issuing_date"]),
        ]

    def __str__(self) -> str:
        """Returns a string representation of the invoice."""
        return f"Invoice {self.invoice_number} ({self.status}) for Tenant {self.tenant_id}"

    @property
    def amount(self) -> float:
        """Returns the subtotal amount of the invoice in major currency units (e.g., dollars)."""
        return float(self.amount_cents) / 100

    @property
    def taxes_amount(self) -> float:
        """Returns the tax amount of the invoice in major currency units."""
        return float(self.taxes_amount_cents) / 100

    @property
    def total_amount(self) -> float:
        """Returns the total amount of the invoice (including taxes) in major currency units."""
        return float(self.total_amount_cents) / 100
