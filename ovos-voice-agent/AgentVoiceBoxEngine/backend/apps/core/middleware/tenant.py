"""
Tenant Context Management Middleware
====================================

This module defines the `TenantMiddleware`, a crucial component for enabling
multi-tenancy in the application. Its primary responsibility is to identify
the current tenant for an incoming request and make this tenant information
globally accessible throughout the request's lifecycle via thread-local storage.

This allows `TenantScopedModel`s and `TenantScopedManager`s to automatically
filter database queries based on the active tenant, ensuring strict data isolation.
"""

import threading
from typing import Optional
from uuid import UUID

from django.http import HttpRequest, HttpResponse, JsonResponse

# Thread-local storage for tenant context. This ensures that the current tenant
# is accessible to any part of the application code within the same request thread.
_tenant_context = threading.local()


def get_current_tenant():
    """
    Retrieves the currently active Tenant object from thread-local storage.

    This function provides a global access point to the tenant associated
    with the ongoing request.

    Returns:
        The Tenant model instance if set, otherwise None.
    """
    return getattr(_tenant_context, "tenant", None)


def get_current_tenant_id() -> Optional[UUID]:
    """
    Retrieves the ID of the currently active Tenant from thread-local storage.

    Returns:
        The UUID of the current tenant if set, otherwise None.
    """
    return getattr(_tenant_context, "tenant_id", None)


def set_current_tenant(tenant) -> None:
    """
    Sets the current Tenant object and its ID in thread-local storage.

    This function is called by `TenantMiddleware` once the tenant has been
    successfully identified and loaded.

    Args:
        tenant: The Tenant model instance to set as the current tenant.
    """
    _tenant_context.tenant = tenant
    _tenant_context.tenant_id = tenant.id if tenant else None


def set_current_tenant_id(tenant_id: Optional[UUID]) -> None:
    """
    Sets only the current tenant ID in thread-local storage.

    Args:
        tenant_id: The UUID of the tenant to set.
    """
    _tenant_context.tenant_id = tenant_id


def clear_current_tenant() -> None:
    """
    Clears the current tenant context from thread-local storage.

    This is important to prevent cross-request contamination in multi-threaded
    environments or long-running processes (e.g., test suites).
    """
    _tenant_context.tenant = None
    _tenant_context.tenant_id = None


# A list of URL paths that do not require an active tenant context.
# Requests to these paths will bypass tenant resolution.
TENANT_EXEMPT_PATHS = [
    "/health/",
    "/metrics",
    "/api/v2/docs",
    "/api/v2/openapi.json",
    "/api/v2/onboarding/signup",
    "/admin/",
]


class TenantMiddleware:
    """
    Django middleware for identifying and validating the current tenant.

    This middleware is responsible for:
    1.  Clearing previous tenant context.
    2.  Checking if the request path is exempt from tenant requirements.
    3.  Attempting to extract a tenant ID from JWT claims, custom headers, or subdomains.
    4.  Loading and validating the identified tenant's status.
    5.  Setting the tenant in thread-local storage and attaching it to the request object.
    6.  Handling scenarios where a tenant is not found, suspended, or deleted.
    7.  Clearing the tenant context after the request is processed.
    """

    def __init__(self, get_response):
        """Initializes the middleware with the next callable in the chain."""
        self.get_response = get_response

    def __call__(self, request: HttpRequest) -> HttpResponse:
        """
        Processes an incoming request to establish the tenant context.

        Args:
            request: The incoming HttpRequest object.

        Returns:
            The HttpResponse generated by the subsequent middleware or view.
        """
        # 1. Clear any existing tenant context from previous requests.
        clear_current_tenant()

        # 2. Check if the request path is explicitly exempt from tenant requirements.
        if self._is_exempt_path(request.path):
            return self.get_response(request)

        # 3. Attempt to extract the tenant ID from various sources in order of precedence.
        tenant_id = self._extract_tenant_id(request)

        if tenant_id:
            # 4. If a tenant ID is found, attempt to load the tenant from the database.
            tenant = self._load_tenant(tenant_id)

            # 5. Handle cases where the tenant is not found or is in an invalid state.
            if tenant is None:
                return JsonResponse(
                    {"error": "tenant_not_found", "message": "Tenant not found"},
                    status=404,
                )
            if tenant.status == "suspended":
                return JsonResponse(
                    {"error": "tenant_suspended", "message": "Tenant account is suspended"},
                    status=403,
                )
            if tenant.status == "deleted":
                return JsonResponse(
                    {"error": "tenant_not_found", "message": "Tenant not found"},
                    status=404,
                )

            # 6. Set the identified and validated tenant in thread-local storage and on the request.
            set_current_tenant(tenant)
            request.tenant = tenant
            request.tenant_id = tenant.id

        # 7. Process the request further down the middleware chain.
        response = self.get_response(request)

        # 8. Clear the tenant context from thread-local storage after the request is handled.
        clear_current_tenant()

        return response

    def _is_exempt_path(self, path: str) -> bool:
        """
        Checks if the given request path is in the list of paths exempt from
        tenant identification.
        """
        for exempt_path in TENANT_EXEMPT_PATHS:
            if path.startswith(exempt_path):
                return True
        return False

    def _extract_tenant_id(self, request: HttpRequest) -> Optional[UUID]:
        """
        Attempts to extract the tenant ID from the request using a defined precedence:
        1.  `jwt_tenant_id` attribute (set by authentication middleware).
        2.  `X-Tenant-ID` HTTP header.
        3.  Subdomain of the request host.

        Args:
            request: The HttpRequest object.

        Returns:
            The UUID of the extracted tenant ID, or None if not found.
        """
        # 1. Check for tenant ID provided by JWT claims (usually set by an auth middleware).
        jwt_tenant_id = getattr(request, "jwt_tenant_id", None)
        if jwt_tenant_id:
            try:
                return UUID(jwt_tenant_id)
            except (ValueError, TypeError):
                # Malformed UUID in JWT, proceed to next source.
                pass

        # 2. Check for tenant ID in the 'X-Tenant-ID' HTTP header.
        header_tenant_id = request.headers.get("X-Tenant-ID")
        if header_tenant_id:
            try:
                return UUID(header_tenant_id)
            except (ValueError, TypeError):
                # Malformed UUID in header, proceed to next source.
                pass

        # 3. Attempt to extract tenant from subdomain (e.g., 'tenant-slug.example.com').
        host = request.get_host().split(":")[0]  # Remove port if present.
        parts = host.split(".")
        # A subdomain usually means at least 3 parts (sub.domain.tld)
        if len(parts) > 2:
            subdomain = parts[0]
            tenant = self._load_tenant_by_slug(subdomain)
            if tenant:
                return tenant.id

        return None

    def _load_tenant(self, tenant_id: UUID):
        """
        Loads a Tenant model instance from the database by its ID.
        (Local import to avoid circular dependency at module level).
        """
        from apps.tenants.models import Tenant

        try:
            return Tenant.objects.get(id=tenant_id)
        except Tenant.DoesNotExist:
            return None

    def _load_tenant_by_slug(self, slug: str):
        """
        Loads a Tenant model instance from the database by its slug.
        (Local import to avoid circular dependency at module level).
        """
        from apps.tenants.models import Tenant

        try:
            return Tenant.objects.get(slug=slug)
        except Tenant.DoesNotExist:
            return None
